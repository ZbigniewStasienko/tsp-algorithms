package SimulatedAnnealing;

import java.util.Arrays;
import java.util.Random;

public class SimulatedAnnealing {
    // Variable to hold the currently considered path
    private int[] currentSolution;
    // Variable to hold the newly designated path
    private int [] newSolution;
    // Variable to store the best solution found
    private int[] bestSolution;
    // Variable to store information about the cost of the best solution found
    private int bestCost;
    // Variable for generating the neighborhood for the path
    private Neighbors neighbors = new Neighbors();
    // Variable that handles path-related operations (e.g. determining the starting path, cost of a given path, etc.)
    private Travel travel;
    // Variable to introduce randomness into the algorithm
    Random random = new Random();
    // Variable informing about the moment when the optimal solution was found
    private long foundTime;

    public SimulatedAnnealing(Graph graph) {
        travel = new Travel(graph);
    }

    public void simulateAnnealing(long time, double coolingRate) {
        // The first solution generated by random method
        currentSolution = travel.generateFirstTravel();
        // Calculate the initial temperatures
        int startingTemperature = travel.calculateInitialTemperature(currentSolution);
        System.out.println("Initial temperature: " + startingTemperature);
        // Setting the course of the minimum path and its cost
        bestCost = travel.getDistance(currentSolution);
        bestSolution = Arrays.copyOf(currentSolution, currentSolution.length);
        // Start timing
        long startTime = System.currentTimeMillis();
        double t = startingTemperature;
        boolean exitCondition = true;
        int iterationSameTemp = currentSolution.length * currentSolution.length;
        int iterationsInCurrentTemp = 0;
        while(exitCondition) {
            // Determine the neighborhood for a given path
            newSolution = neighbors.generateNewRoute(currentSolution);
            int prevCost = travel.getDistance(currentSolution);
            int newCost = travel.getDistance(newSolution);
            // Assessment of the quality of the new solution
            double fitness = ((double) 1 / newCost) - ((double) 1 / prevCost);
            iterationsInCurrentTemp++;
            // Update the best solution and the time it was found
            if(bestCost > newCost){
                bestCost = newCost;
                bestSolution = Arrays.copyOf(newSolution, newSolution.length);
                foundTime = System.currentTimeMillis() - startTime;
            }
            // Accept the new solution as the one currently being considered
            if(fitness > 0){
                currentSolution = newSolution;
            } else {
                // We are investigating the possibility of adopting a worse solution depending on the current temperature
                if (random.nextDouble() <= Math.exp(fitness / t)) {
                    currentSolution = newSolution;
                }
            }
            // Temperature change when a certain number of iterations in an epoch is reached
            if(iterationsInCurrentTemp >= iterationSameTemp) {
                t = t * coolingRate;
                iterationsInCurrentTemp = 0;
            }
            // Check the exit condition
            if ((System.currentTimeMillis() - startTime) > time) {
                System.out.println("Output temperature: " + t);
                exitCondition = false;
            }
        }
    }

    public void printResults() {
        System.out.println("Route found:");
        travel.printRoute(bestSolution);
        System.out.println("\nCost of the route: " + bestCost);
        System.out.println("Found within " + foundTime + "ms of the algorithm running \n");
    }

}
